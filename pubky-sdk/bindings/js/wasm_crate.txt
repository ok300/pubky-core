./scripts/bundle_npm.rs
```
use std::env;
use std::io;
use std::process::{Command, ExitStatus};

// If the process hangs, try `cargo clean` to remove all locks.

fn main() {
    println!("Building wasm for pubky...");

    build_wasm("nodejs").unwrap();
    patch().unwrap();
}

fn build_wasm(target: &str) -> io::Result<ExitStatus> {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");

    let output = Command::new("wasm-pack")
        .args([
            "build",
            &manifest_dir,
            "--release",
            "--target",
            target,
            "--out-dir",
            &format!("pkg/{}", target),
            "--out-name",
            "pubky",
        ])
        .output()?;

    println!(
        "wasm-pack {target} output: {}",
        String::from_utf8_lossy(&output.stdout)
    );

    if !output.status.success() {
        eprintln!(
            "wasm-pack failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    Ok(output.status)
}

fn patch() -> io::Result<ExitStatus> {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");

    println!("{manifest_dir}/scripts/patch.mjs");
    let output = Command::new("node")
        .args([format!("{manifest_dir}/scripts/patch.mjs")])
        .output()?;

    println!(
        "patch.mjs output: {}",
        String::from_utf8_lossy(&output.stdout)
    );

    if !output.status.success() {
        eprintln!(
            "patch.mjs failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    Ok(output.status)
}
```
./pkg/nodejs/README.md
```
# JS Pubky SDK bindings

Wasm-pack wrap of [Pubky](https://github.com/pubky/pubky-core) SDK.

## How To Build/Test the NPM Package

1. Go to `pubky-sdk/bindings/js/pkg`.
2. Run `npm run build`.
3. Run a testnet mainline DHT, Pkarr relay and Homeserver `npm run testnet`
4. Run tests with `npm run test`.
```
./pkg/README.md
```
# Pubky

WASM/JS client for the [Pubky](https://github.com/pubky/pubky-core) SDK.

- Works in browsers and Node 20+.
- First-class Signer/Session model.
- Public & session-scoped storage helpers.
- PKDNS (Pkarr) resolve/publish for homeservers.
- Simple `AuthFlow` for pubkyauth.

## Install

```bash
npm install @synonymdev/pubky
```

> **Node**: requires Node v20+ (undici fetch, WebCrypto).

## Getting Started

```js
import { Pubky, PublicKey, Keypair } from "@synonymdev/pubky";

// Initiate a Pubky SDK facade wired for default mainnet Pkarr relays.
const pubky = new Pubky(); // or: const pubky = Pubky.testnet(); for localhost testnet.

// 1) Create a random user keys and bound to a new Signer.
const keypair = Keypair.random();
const signer = pubky.signer(keypair);

// 2) Sign up at a homeserver (optionally with an invite)
const homeserver = PublicKey.from(
  "8pinxxgqs41n4aididenw5apqp1urfmzdztr8jt4abrkdn435ewo"
);
const signupToken = "<your-invite-code-or-null>";
const session = await signer.signup(homeserver, signupToken);

// 3) Write a public JSON file (session-scoped storage uses cookies automatically)
const path = "/pub/example.com/hello.json";
await session.storage().putJson(path, { hello: "world" });

// 4) Read it publicly (no auth needed)
const userPk = session.info().publicKey();
const addr = `${userPk.z32()}/pub/example.com/hello.json`;
const json = await pubky.publicStorage().getJson(addr); // -> { hello: "world" }
```

Find here [**ready-to-run examples**](https://github.com/pubky/pubky-core/tree/main/examples).

## API Overview

Façade `Pubky` to quickly get any flow started:

```js
import { Pubky, Keypair } from "@synonymdev/pubky";

// Mainnet (default relays)
const pubky = new Pubky();

// Local testnet wiring (Pkarr + HTTP mapping).
// Omit the argument for "localhost".
const pubkyLocal = Pubky.testnet("localhost");

// Signers (bind your keypair to the façade)
const signer = pubky.signer(Keypair.random());

// Public storage (read-only)
const publicStorage = pubky.publicStorage();

// PKDNS resolver (read-only)
const pkdns = pubky.pkdns();

// Optional: raw HTTP client for advanced use
const client = pubky.client();
```

### Client (HTTP bridge)

```js
import { Client } from "@synonymdev/pubky";

const client = new Client(); // or: pubky.client(); instead of constructing a client manually

// Works with both pubky:// and http(s)://
const res = await client.fetch("pubky://<pubky>/pub/example.com/file.txt");
```

---

### Keys

```js
import { Keypair, PublicKey } from "@synonymdev/pubky";

const keypair = Keypair.random();
const pubkey = keypair.publicKey();

// z-base-32 roundtrip
const parsed = PublicKey.from(pubkey.z32());
```

#### Recovery file (encrypt/decrypt root secret)

```js
// Encrypt to recovery file (Uint8Array)
const recoveryFile = keypair.createRecoveryFile("strong passphrase");

// Decrypt back into a Keypair
const restored = Keypair.fromRecoveryFile(recoveryFile, "strong passphrase");

// Build a Signer from a recovered key
const signer = pubky.signer(restored);
```

- keypair: An instance of [Keypair](#keypair).
- passphrase: A utf-8 string [passphrase](https://www.useapassphrase.com/).
- Returns: A recovery file with a spec line and an encrypted secret key.

---

### Signer & Session

```js
import { Pubky, PublicKey, Keypair } from "@synonymdev/pubky";

const pubky = new Pubky();

const keypair = Keypair.random();
const signer = pubky.signer(keypair);

const homeserver = PublicKey.from("8pinxxgq…");
const session = await signer.signup(homeserver, /* invite */ null);

const session2 = await signer.signin(); // fast, prefer this; publishes PKDNS in background
const session3 = await signer.signinBlocking(); // slower but safer; waits for PKDNS publish

await session.signout(); // invalidates server session
```

**Session details**

```js
const info = session.info();
const userPk = info.publicKey(); // -> PublicKey
const caps = info.capabilities(); // -> string[]

const storage = session.storage(); // -> SessionStorage (absolute paths)
```

**Approve a pubkyauth request URL**

```js
await signer.approveAuthRequest("pubkyauth:///?caps=...&secret=...&relay=...");
```

---

### AuthFlow (pubkyauth)

End-to-end auth (3rd-party app asks a user to approve via QR/deeplink, E.g. Pubky Ring).

```js
import { Pubky } from "@synonymdev/pubky";
const pubky = new Pubky();

// Comma-separated capabilities string
const caps = "/pub/my.app/:rw,/pub/another.app/folder/:w";

// Optional relay; defaults to Synonym-hosted relay if omitted
const relay = "https://httprelay.pubky.app/link/"; // optional (defaults to this)

// Start the auth polling
const flow = pubky.startAuthFlow(caps, relay);

renderQr(flow.authorizationUrl()); // show to user

// Blocks until the signer approves; returns a ready Session
const session = await flow.awaitApproval();
```

---

### Storage

#### PublicStorage (read-only)

```js
const pub = pubky.publicStorage();

// Reads
await pub.getJson(`${userPk.z32()}/pub/example.com/data.json`);
await pub.getText(`${userPk.z32()}/pub/example.com/readme.txt`);
await pub.getBytes(`${userPk.z32()}/pub/example.com/icon.png`); // Uint8Array

// Metadata
await pub.exists(`${userPk.z32()}/pub/example.com/foo`); // boolean
await pub.stats(`${userPk.z32()}/pub/example.com/foo`); // { content_length, content_type, etag, last_modified } | null

// List directory (addressed path "<pubky>/pub/.../")
// list(addr, cursor=null|suffix|fullUrl, reverse=false, limit?, shallow=false)
await pub.list(`${userPk.z32()}/pub/example.com/`, null, false, 100, false);
```

#### SessionStorage (read/write; uses cookies)

```js
const s = session.storage();

// Writes
await s.putJson("/pub/example.com/data.json", { ok: true });
await s.putText("/pub/example.com/note.txt", "hello");
await s.putBytes("/pub/example.com/img.bin", new Uint8Array([1, 2, 3]));

// Reads
await s.getJson("/pub/example.com/data.json");
await s.getText("/pub/example.com/note.txt");
await s.getBytes("/pub/example.com/img.bin");

// Metadata
await s.exists("/pub/example.com/data.json");
await s.stats("/pub/example.com/data.json");

// Listing (session-scoped absolute dir)
await s.list("/pub/example.com/", null, false, 100, false);

// Delete
await s.delete("/pub/example.com/data.json");
```

Path rules:

- Session storage uses **absolute** paths like `"/pub/app/file.txt"`.
- Public storage uses **addressed** form `<user>/pub/app/file.txt` (or `pubky://<user>/...`).

**Convention:** put your app’s public data under a domain-like folder in `/pub`, e.g. `/pub/mycoolnew.app/`.

---

### PKDNS (Pkarr)

Resolve or publish `_pubky` records.

```js
import { Pubky, PublicKey, Keypair } from "@synonymdev/pubky";

const pubky = new Pubky();

// Read-only resolver
const resolver = pubky.pkdns();
const homeserver = await resolver.getHomeserverOf(PublicKey.from("<user-z32>")); // string | undefined

// With keys (signer-bound)
const signer = pubky.signer(Keypair.random());

// Republish if missing or stale (reuses current host unless overridden)
await signer.pkdns().publishHomeserverIfStale();
// Or force an override now:
await signer.pkdns().publishHomeserverForce(/* optional override homeserver*/);
```

---

## Errors

All async methods throw a structured `PubkyJsError`:

```ts
type PubkyJsError = {
  name:
    | "RequestError" // network/server/validation/JSON
    | "InvalidInput"
    | "AuthenticationError"
    | "PkarrError"
    | "InternalError";
  message: string;
  statusCode?: number; // present for HTTP server errors (4xx/5xx)
};
```

Example:

```js
try {
  await publicStorage.getJson(`${pk}/pub/example.com/missing.json`);
} catch (e) {
  if (e.name === "RequestError" && e.statusCode === 404) {
    // handle not found
  }
}
```

---

## Local Test & Development

For test and development, you can run a local homeserver in a test network.

1. Install Rust (for wasm builds):

```bash
curl https://sh.rustup.rs -sSf | sh
```

2. Run the local testnet:

```bash
npm run testnet
```

3. Point the SDK at testnet:

```js
import { Pubky } from "@synonymdev/pubky";

const pubky = Pubky.testnet(); // defaults to localhost
// or: const pubky = Pubky.testnet("testnet-host");  // custom host (e.g. Docker bridge)
```

---

MIT © Synonym
```
./src/wrappers/session_info.rs
```
use pubky_common::session;

use wasm_bindgen::prelude::*;

use super::keys::PublicKey;

/// Static snapshot of session metadata.
#[wasm_bindgen]
pub struct SessionInfo(pub(crate) session::SessionInfo);

#[wasm_bindgen]
impl SessionInfo {
    /// The user’s public key for this session.
    ///
    /// @returns {PublicKey}
    #[wasm_bindgen(js_name = "publicKey")]
    pub fn public_key(&self) -> PublicKey {
        self.0.public_key().clone().into()
    }

    /// Effective capabilities granted to this session.
    ///
    /// @returns {string[]} Normalized capability entries (e.g. `"/pub/app/:rw"`).
    pub fn capabilities(&self) -> Vec<String> {
        self.0
            .capabilities()
            .iter()
            .map(|c| c.to_string())
            .collect()
    }
}
```
./src/wrappers/auth_token.rs
```
//! WASM wrapper for `pubky::AuthToken`.
//!
//! This type represents a signed, time-bound authentication token produced by a Pubky **Signer**.
//! In browser/Node apps, you’ll most often get it from `AuthFlow.awaitToken()` when you only
//! need to authenticate a user (prove control of a key) without establishing a homeserver session.
//
//  JS quick look:
//
//    import { AuthFlow } from "@synonymdev/pubky";
//
//    const flow = pubky.startAuthFlow("", relay); // no capabilities => auth-only
//    const token = await flow.awaitToken();       // <- AuthToken
//
//    // Who just authenticated?
//    console.log(token.publicKey().z32());
//
//    // Optional: send to your backend and verify there
//    const bytes = token.toBytes();               // Uint8Array
//    // server -> AuthToken.verify(bytes)
//
//  NOTE: `AuthToken.verify(bytes)` does **not** require network access. It checks:
//    - version, signature, allowed timestamp window, replay protection (if using `AuthVerifier` on server).
//

use js_sys::Array;
use wasm_bindgen::prelude::*;

use crate::js_error::JsResult;
use crate::wrappers::keys::PublicKey;

/// AuthToken: signed, time-bound proof of key ownership.
///
/// Returned by [`AuthFlow.awaitToken()`] on the 3rd-party app side when doing **authentication-only**
/// flows (no homeserver session). You can inspect who authenticated and which capabilities were
/// requested, or serialize the token and send it to a backend to verify.
///
/// ### Typical usage
/// ```js
/// // Start an auth-only flow (no capabilities)
/// const flow = pubky.startAuthFlow("", relay);
///
/// // Wait for the signer to approve; returns an AuthToken
/// const token = await flow.awaitToken();
///
/// // Identify the user
/// console.log(token.publicKey().z32());
///
/// // Optionally forward to a server for verification:
/// await fetch("/api/verify", { method: "POST", body: token.toBytes() });
/// ```
///
/// ### Binary format
/// `AuthToken` serializes to a canonical binary (postcard) form; use [`AuthToken.toBytes()`] to get a
/// `Uint8Array`, and [`AuthToken.verify()`] to parse + verify on the server.
#[wasm_bindgen]
pub struct AuthToken(pub(crate) pubky::AuthToken);

#[wasm_bindgen]
impl AuthToken {
    // ---------------------------------------------------------------------
    // Constructors / statics
    // ---------------------------------------------------------------------

    /// Parse and verify an `AuthToken` from its canonical bytes.
    ///
    /// - Verifies version, timestamp freshness window, and signature.
    /// - Throws on invalid/expired/unknown version.
    ///
    /// Use this on your server after receiving `Uint8Array` from the client.
    ///
    /// ```js
    /// import { AuthToken } from "@synonymdev/pubky";
    ///
    /// export async function POST(req) {
    ///   const bytes = new Uint8Array(await req.arrayBuffer());
    ///   const token = AuthToken.verify(bytes); // throws on failure
    ///   return new Response(token.publicKey().z32(), { status: 200 });
    /// }
    /// ```
    #[wasm_bindgen(js_name = "verify")]
    pub fn verify_js(bytes: js_sys::Uint8Array) -> JsResult<AuthToken> {
        let vec = bytes.to_vec();
        let token = pubky::AuthToken::verify(&vec)?; // maps to PubkyJsError on failure
        Ok(AuthToken(token))
    }

    /// Deserialize an `AuthToken` **without** verification.
    ///
    /// Most apps should call [`AuthToken.verify()`]. This is provided for tooling or diagnostics
    /// where you want to inspect the structure first.
    ///
    /// Throws if the bytes cannot be parsed as a valid serialized token.
    #[wasm_bindgen(js_name = "fromBytes")]
    pub fn from_bytes(bytes: js_sys::Uint8Array) -> JsResult<AuthToken> {
        let vec = bytes.to_vec();
        let token = pubky::AuthToken::deserialize(&vec)?; // parse only
        Ok(AuthToken(token))
    }

    // ---------------------------------------------------------------------
    // Instance methods
    // ---------------------------------------------------------------------

    /// Returns the **public key** that authenticated with this token.
    ///
    /// Use `.z32()` on the returned `PublicKey` to get the string form.
    ///
    /// ```js
    /// const who = token.publicKey().z32();
    /// ```
    #[wasm_bindgen(js_name = "publicKey")]
    pub fn public_key(&self) -> PublicKey {
        // `pubky::PublicKey` implements `Clone`
        PublicKey(self.0.public_key().clone())
    }

    /// Returns the **capabilities** requested by the flow at the time this token was signed.
    ///
    /// Most auth-only flows pass an empty string to `startAuthFlow("", relay)`, so this will
    /// commonly be an empty array.
    ///
    /// Returns: `string[]`, where each item is the canonical entry `"<scope>:<actions>"`.
    ///
    /// Example entry: `"/pub/my.app/:rw"`
    #[wasm_bindgen]
    pub fn capabilities(&self) -> Array {
        let arr = Array::new();
        for cap in self.0.capabilities().iter() {
            arr.push(&JsValue::from_str(&cap.to_string()));
        }
        arr
    }

    /// Serialize the token to a `Uint8Array` in its **canonical** (postcard) binary format.
    ///
    /// Use this to send the token to a backend for verification.
    ///
    /// ```js
    /// const bytes = token.toBytes();
    /// await fetch("/api/verify", { method: "POST", body: bytes });
    /// ```
    #[wasm_bindgen(js_name = "toBytes")]
    pub fn to_bytes(&self) -> js_sys::Uint8Array {
        let bytes = self.0.serialize();
        js_sys::Uint8Array::from(bytes.as_slice())
    }
}
```
./src/wrappers/mod.rs
```
pub mod auth_token;
pub mod capabilities;
pub mod keys;
pub mod session_info;
```
./src/wrappers/capabilities.rs
```
// A builder pattern like Capabilities::build() is unusual an overkill for JS
// but we still want parsing/validation and failing fast from wrong capabilities
// strings

use js_sys::Array;
use wasm_bindgen::prelude::*;

use crate::js_error::{JsResult, PubkyErrorName, PubkyJsError};
use pubky_common::capabilities::{Capabilities, Capability};

/// Internal helper: normalizes capabilities and collects invalid tokens.
fn normalize_and_collect(input: &str) -> (String, Vec<String>) {
    let mut valid = Vec::new();
    let mut invalid = Vec::new();

    for tok in input.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()) {
        match Capability::try_from(tok) {
            Ok(cap) => valid.push(cap),
            Err(_) => invalid.push(tok.to_string()),
        }
    }

    let normalized = Capabilities(valid).to_string(); // normalizes action order (:rw)
    (normalized, invalid)
}

/// Validate and normalize a capabilities string.
///
/// - Normalizes action order (`wr` -> `rw`)
/// - Throws `InvalidInput` listing malformed entries.
///
/// @param {string} input
/// @returns {string} Normalized string (same shape as input).
/// @throws {PubkyJsError} `{ name: "InvalidInput" }` with a helpful message.
#[wasm_bindgen(js_name = "validateCapabilities")]
pub fn validate_capabilities(input: &str) -> JsResult<String> {
    let (normalized, invalid) = normalize_and_collect(input);

    if !invalid.is_empty() {
        // Human-friendly message: comma-separated list of bad entries
        let joined = invalid.join(", ");

        // Structured payload for programmatic handling
        let arr = Array::new();
        for s in invalid {
            arr.push(&JsValue::from_str(&s));
        }

        return Err(PubkyJsError::new(
            PubkyErrorName::InvalidInput,
            format!("Invalid capability entries: {joined}"),
        ));
    }

    Ok(normalized)
}

/// Internal: same as `validateCapabilities` but returns a Rust error.
pub(crate) fn validate_caps_for_start(input: &str) -> Result<String, PubkyJsError> {
    validate_capabilities(input)
}
```
./src/wrappers/keys.rs
```
use wasm_bindgen::prelude::*;

use crate::js_error::JsResult;
use js_sys::Uint8Array;

#[wasm_bindgen]
pub struct Keypair(pkarr::Keypair);

#[wasm_bindgen]
impl Keypair {
    #[wasm_bindgen]
    /// Generate a random [Keypair]
    pub fn random() -> Self {
        Self(pkarr::Keypair::random())
    }

    /// Generate a [Keypair] from a secret key.
    #[wasm_bindgen(js_name = "fromSecretKey")]
    pub fn from_secret_key(secret_key: Vec<u8>) -> Result<Keypair, JsValue> {
        let secret_len = secret_key.len();
        let secret: [u8; 32] = secret_key
            .try_into()
            .map_err(|_| format!("Expected secret_key to be 32 bytes, got {}", secret_len))?;
        Ok(Self(pkarr::Keypair::from_secret_key(&secret)))
    }

    /// Returns the secret key of this keypair.
    #[wasm_bindgen(js_name = "secretKey")]
    pub fn secret_key(&self) -> Uint8Array {
        Uint8Array::from(self.0.secret_key().as_ref())
    }

    /// Returns the [PublicKey] of this keypair.
    #[wasm_bindgen(js_name = "publicKey")]
    pub fn public_key(&self) -> PublicKey {
        PublicKey(self.0.public_key())
    }

    /// Create a recovery file for this keypair (encrypted with the given passphrase).
    #[wasm_bindgen(js_name = "createRecoveryFile")]
    pub fn create_recovery_file(&self, passphrase: &str) -> Uint8Array {
        pubky_common::recovery_file::create_recovery_file(self.as_inner(), passphrase)
            .as_slice()
            .into()
    }

    /// Decrypt a recovery file and return a Keypair (decrypted with the given passphrase).
    #[wasm_bindgen(js_name = "fromRecoveryFile")]
    pub fn from_recovery_file(recovery_file: &[u8], passphrase: &str) -> JsResult<Keypair> {
        let keypair =
            pubky_common::recovery_file::decrypt_recovery_file(recovery_file, passphrase)?;
        Ok(Keypair::from(keypair))
    }
}

impl Keypair {
    pub fn as_inner(&self) -> &pkarr::Keypair {
        &self.0
    }
}

impl From<pkarr::Keypair> for Keypair {
    fn from(keypair: pkarr::Keypair) -> Self {
        Self(keypair)
    }
}

#[wasm_bindgen]
pub struct PublicKey(pub(crate) pkarr::PublicKey);

#[wasm_bindgen]
impl PublicKey {
    /// Convert the PublicKey to Uint8Array
    #[wasm_bindgen(js_name = "toUint8Array")]
    pub fn to_uint8array(&self) -> Uint8Array {
        Uint8Array::from(self.0.as_bytes().as_ref())
    }

    #[wasm_bindgen]
    /// Returns the z-base32 encoding of this public key
    pub fn z32(&self) -> String {
        self.0.to_string()
    }

    #[wasm_bindgen(js_name = "from")]
    /// @throws
    pub fn try_from(value: String) -> JsResult<PublicKey> {
        let native_pk = pkarr::PublicKey::try_from(value)?;
        Ok(PublicKey(native_pk))
    }
}

impl PublicKey {
    pub fn as_inner(&self) -> &pkarr::PublicKey {
        &self.0
    }
}

impl From<pkarr::PublicKey> for PublicKey {
    fn from(value: pkarr::PublicKey) -> Self {
        PublicKey(value)
    }
}
```
./src/actors/storage/session.rs
```
// js/src/client/storage/session.rs
use js_sys::Uint8Array;
use serde::Serialize;
use wasm_bindgen::prelude::*;

use super::stats::ResourceStats;
use crate::js_error::JsResult;

/// Read/write storage scoped to **your** session (absolute paths: `/pub/...`).
#[wasm_bindgen]
pub struct SessionStorage(pub(crate) pubky::SessionStorage);

#[wasm_bindgen]
impl SessionStorage {
    /// List a directory (absolute session path). Returns `pubky://…` URLs.
    ///
    /// @param {string} path Must end with `/`.
    /// @param {string|null=} cursor Optional suffix or full URL to start **after**.
    /// @param {boolean=} reverse Default `false`.
    /// @param {number=} limit Optional result limit.
    /// @param {boolean=} shallow Default `false`.
    /// @returns {Promise<string[]>}
    #[wasm_bindgen]
    pub async fn list(
        &self,
        path: &str,
        cursor: Option<String>,
        reverse: Option<bool>,
        limit: Option<u16>,
        shallow: Option<bool>,
    ) -> JsResult<Vec<String>> {
        let mut b = self.0.list(path)?;
        if let Some(c) = cursor {
            b = b.cursor(&c);
        }
        if let Some(r) = reverse {
            b = b.reverse(r);
        }
        if let Some(l) = limit {
            b = b.limit(l);
        }
        if let Some(s) = shallow {
            b = b.shallow(s);
        }
        let urls = b.send().await?.into_iter().map(|u| u.to_string()).collect();
        Ok(urls)
    }

    /// GET bytes from an absolute session path.
    ///
    /// @param {string} path
    /// @returns {Promise<Uint8Array>}
    #[wasm_bindgen(js_name = "getBytes")]
    pub async fn get_bytes(&self, path: &str) -> JsResult<Uint8Array> {
        let resp = self.0.get(path).await?;
        let bytes = resp.bytes().await?;
        Ok(Uint8Array::from(bytes.as_ref()))
    }

    /// GET text from an absolute session path.
    ///
    /// @param {string} path
    /// @returns {Promise<string>}
    #[wasm_bindgen(js_name = "getText")]
    pub async fn get_text(&self, path: &str) -> JsResult<String> {
        let resp = self.0.get(path).await?;
        Ok(resp.text().await?)
    }

    /// GET JSON from an absolute session path.
    ///
    /// @param {string} path
    /// @returns {Promise<any>}
    #[wasm_bindgen(js_name = "getJson")]
    pub async fn get_json(&self, addr: &str) -> JsResult<JsValue> {
        let v: serde_json::Value = self.0.get_json(addr).await?;
        let ser = serde_wasm_bindgen::Serializer::new().serialize_maps_as_objects(true);
        Ok(v.serialize(&ser)?)
    }

    /// Check existence.
    ///
    /// @param {string} path
    /// @returns {Promise<boolean>}
    #[wasm_bindgen]
    pub async fn exists(&self, path: &str) -> JsResult<bool> {
        Ok(self.0.exists(path).await?)
    }

    /// Get metadata for an absolute, session-scoped path (e.g. `"/pub/app/file.json"`).
    ///
    /// @param {string} path Absolute path under your user (starts with `/`).
    /// @returns {Promise<ResourceStats|undefined>} `undefined` if the resource does not exist.
    /// @throws {PubkyJsError} On invalid input or transport/server errors.
    #[wasm_bindgen(js_name = "stats")]
    pub async fn stats(&self, path: &str) -> JsResult<Option<ResourceStats>> {
        match self.0.stats(path).await? {
            Some(stats) => Ok(Some(ResourceStats::from(stats))),
            None => Ok(None),
        }
    }

    /// PUT binary at an absolute session path.
    ///
    /// @param {string} path
    /// @param {Uint8Array} bytes
    /// @returns {Promise<void>}
    #[wasm_bindgen(js_name = "putBytes")]
    pub async fn put_bytes(&self, path: &str, body: &[u8]) -> JsResult<()> {
        self.0.put(path, body.to_vec()).await?;
        Ok(())
    }

    /// PUT text at an absolute session path.
    ///
    /// @param {string} path
    /// @param {string} text
    /// @returns {Promise<void>}
    #[wasm_bindgen(js_name = "putText")]
    pub async fn put_text(&self, path: &str, body: &str) -> JsResult<()> {
        self.0.put(path, body.as_bytes().to_vec()).await?;
        Ok(())
    }

    /// PUT JSON at an absolute session path.
    ///
    /// @param {string} path Absolute path (e.g. `"/pub/app/data.json"`).
    /// @param {any} value JSON-serializable value.
    /// @returns {Promise<void>}
    #[wasm_bindgen(js_name = "putJson")]
    pub async fn put_json(&self, path: &str, body: JsValue) -> JsResult<()> {
        let v: serde_json::Value = serde_wasm_bindgen::from_value(body)?;
        self.0.put_json(path, &v).await?;
        Ok(())
    }

    /// Delete a path (file or empty directory).
    ///
    /// @param {string} path
    /// @returns {Promise<void>}
    #[wasm_bindgen]
    pub async fn delete(&self, path: &str) -> JsResult<()> {
        self.0.delete(path).await?;
        Ok(())
    }
}
```
./src/actors/storage/mod.rs
```
mod public;
mod session;
pub mod stats;

pub use public::PublicStorage;
pub use session::SessionStorage;
```
./src/actors/storage/public.rs
```
// js/src/client/storage/public.rs
use super::stats::ResourceStats;
use js_sys::Uint8Array;
use serde::Serialize;
use wasm_bindgen::prelude::*;

use crate::js_error::JsResult;

/// Read-only public storage using addressed paths (`"<user-z32>/pub/...")`.
#[wasm_bindgen]
pub struct PublicStorage(pub(crate) pubky::PublicStorage);

#[wasm_bindgen]
impl PublicStorage {
    /// Construct PublicStorage using global client (mainline relays).
    #[wasm_bindgen(constructor)]
    pub fn new() -> JsResult<PublicStorage> {
        Ok(PublicStorage(pubky::PublicStorage::new()?))
    }

    /// List a directory. Results are `pubky://…` absolute URLs.
    ///
    /// @param {string} address Addressed directory (must end with `/`).
    /// @param {string|null=} cursor Optional suffix or full URL to start **after**.
    /// @param {boolean=} reverse Default `false`. When `true`, newest/lexicographically-last first.
    /// @param {number=} limit Optional result limit.
    /// @param {boolean=} shallow Default `false`. When `true`, lists only first-level entries.
    /// @returns {Promise<string[]>}
    #[wasm_bindgen]
    pub async fn list(
        &self,
        address: &str,
        cursor: Option<String>,
        reverse: Option<bool>,
        limit: Option<u16>,
        shallow: Option<bool>,
    ) -> JsResult<Vec<String>> {
        let mut b = self.0.list(address)?;
        if let Some(c) = cursor {
            b = b.cursor(&c);
        }
        if let Some(r) = reverse {
            b = b.reverse(r);
        }
        if let Some(l) = limit {
            b = b.limit(l);
        }
        if let Some(s) = shallow {
            b = b.shallow(s);
        }

        let urls = b.send().await?.into_iter().map(|u| u.to_string()).collect();
        Ok(urls)
    }

    /// Fetch bytes from an addressed path.
    ///
    /// @param {string} address
    /// @returns {Promise<Uint8Array>}
    #[wasm_bindgen(js_name = "getBytes")]
    pub async fn get_bytes(&self, address: &str) -> JsResult<Uint8Array> {
        let resp = self.0.get(address).await?;
        let bytes = resp.bytes().await?;
        Ok(Uint8Array::from(bytes.as_ref()))
    }

    /// Fetch text from an addressed path as UTF-8 text.
    ///
    /// @param {string} address
    /// @returns {Promise<string>}
    #[wasm_bindgen(js_name = "getText")]
    pub async fn get_text(&self, address: &str) -> JsResult<String> {
        let resp = self.0.get(address).await?;
        Ok(resp.text().await?)
    }

    /// Fetch JSON from an addressed path.
    ///
    /// @param {string} address `"<user-z32>/pub/.../file.json"` or `pubky://<user>/pub/...`.
    /// @returns {Promise<any>}
    #[wasm_bindgen(js_name = "getJson")]
    pub async fn get_json(&self, address: &str) -> JsResult<JsValue> {
        let v: serde_json::Value = self.0.get_json(address).await?;
        let ser = serde_wasm_bindgen::Serializer::new().serialize_maps_as_objects(true);
        Ok(v.serialize(&ser)?)
    }

    /// Check if a path exists.
    ///
    /// @param {string} address
    /// @returns {Promise<boolean>}
    #[wasm_bindgen]
    pub async fn exists(&self, address: &str) -> JsResult<bool> {
        Ok(self.0.exists(address).await?)
    }

    /// Get metadata for an address
    ///
    /// @param {string} address `"<user-z32>/pub/.../file.json"` or `pubky://<user>/pub/...`.
    /// @returns {Promise<ResourceStats|undefined>} `undefined` if the resource does not exist.
    /// @throws {PubkyJsError} On invalid input or transport/server errors.
    #[wasm_bindgen(js_name = "stats")]
    pub async fn stats(&self, address: &str) -> JsResult<Option<ResourceStats>> {
        match self.0.stats(address).await? {
            Some(stats) => Ok(Some(ResourceStats::from(stats))),
            None => Ok(None),
        }
    }
}
```
./src/actors/storage/stats.rs
```
use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::prelude::*;

/// Resource metadata returned by `SessionStorage.stats()` and `PublicStorage.stats()`.
///
/// @typedef {Object} ResourceStats
/// @property {number=} contentLength  Size in bytes.
/// @property {string=} contentType    Media type (e.g. "application/json; charset=utf-8").
/// @property {number=} lastModifiedMs Unix epoch milliseconds.
/// @property {string=} etag           Opaque server ETag for the current version.
///
/// @example
/// const stats = await pubky.publicStorage().stats(`${user}/pub/app/file.json`);
/// if (stats) {
///   console.log(stats.contentLength, stats.contentType, stats.lastModifiedMs);
/// }
///
/// Notes:
/// - `contentLength` equals `getBytes(...).length`.
/// - `etag` may be absent and is opaque; compare values to detect updates.
/// - `lastModifiedMs` increases when the resource is updated.
#[derive(Tsify, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct ResourceStats {
    /// Size in bytes of the stored object.
    #[tsify(optional)]
    pub content_length: Option<u64>,

    /// Media type of the stored object (e.g., `"application/json"`).
    #[tsify(optional)]
    pub content_type: Option<String>,

    /// Unix epoch **milliseconds** for the last modification time.
    #[tsify(optional)]
    pub last_modified_ms: Option<u64>,

    /// Opaque entity tag identifying the current stored version.
    #[tsify(optional)]
    pub etag: Option<String>,
}

impl From<pubky::ResourceStats> for ResourceStats {
    fn from(s: pubky::ResourceStats) -> Self {
        let last_modified_ms = s.last_modified.map(|t| {
            t.duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as u64
        });
        Self {
            content_length: s.content_length,
            content_type: s.content_type,
            last_modified_ms,
            etag: s.etag,
        }
    }
}
```
./src/actors/auth_flow.rs
```
use pubky_common::capabilities::Capabilities;
use url::Url;
use wasm_bindgen::prelude::*;

use super::session::Session;
use crate::{
    js_error::JsResult,
    wrappers::{auth_token::AuthToken, capabilities::validate_caps_for_start},
};

/// Start and control a pubkyauth authorization flow.
///
/// Typical flow:
/// 1) `AuthFlow.start(...)` or `pubky.startAuthFlow(...)`
/// 2) Show `authorizationUrl()` as QR/deeplink to the user’s signing device
/// 3) `awaitApproval()` to receive a ready `Session`
#[wasm_bindgen]
pub struct AuthFlow(pub(crate) pubky::PubkyAuthFlow);

#[wasm_bindgen]
impl AuthFlow {
    /// Start a flow (standalone).
    /// Prefer `pubky.startAuthFlow()` to reuse a façade client.
    ///
    /// @param {string} capabilities
    /// Comma-separated capabilities, e.g. `"/pub/app/:rw,/priv/foo.txt:r"`.
    /// Each entry must be `"<scope>:<actions>"`, where:
    /// - `scope` starts with `/` (e.g. `/pub/example.app/`)
    /// - `actions` is any combo of `r` and/or `w` (order is normalized; `wr` -> `rw`)
    /// Empty string is allowed (no scopes).
    ///
    /// @param {string} [relay]
    /// Optional HTTP relay base, e.g. `"https://demo.httprelay.io/link/"`.
    /// Defaults to the default Synonym-hosted relay when omitted.
    ///
    /// @returns {AuthFlow}
    /// A running auth flow. Call `authorizationUrl()` to show the deep link,
    /// then `awaitApproval()` to receive a `Session`.
    /// @throws {PubkyJsError}
    /// - `{ name: "InvalidInput", mesage: string }` if any capability entry is invalid
    ///     or for an invalid relay URL.
    /// @example
    /// const flow = AuthFlow.start("/pub/my.app/:rw,/pub/pubky.app/:w");
    /// renderQRCode(flow.authorizationUrl());
    /// const session = await flow.awaitApproval();
    #[wasm_bindgen(js_name = "start")]
    pub fn start(capabilities: &str, relay: Option<String>) -> JsResult<AuthFlow> {
        Self::start_with_client(capabilities, relay, None)
    }

    /// Internal helper that threads an explicit transport.
    pub(crate) fn start_with_client(
        capabilities: &str,
        relay: Option<String>,
        client: Option<pubky::PubkyHttpClient>,
    ) -> JsResult<AuthFlow> {
        // 1) Validate & normalize capability string
        let normalized = validate_caps_for_start(capabilities)?;
        // 2) Build native Capabilities
        let caps = Capabilities::try_from(normalized.as_str())?;

        // 3) Build the flow with optional relay and optional client
        let mut builder = pubky::PubkyAuthFlow::builder(&caps);
        if let Some(c) = client {
            builder = builder.client(c);
        }
        if let Some(r) = relay {
            builder = builder.relay(Url::parse(&r)?);
        }

        Ok(AuthFlow(builder.start()?))
    }

    /// Return the authorization deep link (URL) to show as QR or open on the signer device.
    ///
    /// @returns {string} A `pubkyauth://…` or `https://…` URL with channel info.
    ///
    /// @example
    /// renderQr(flow.authorizationUrl());
    #[wasm_bindgen(js_name = "authorizationUrl")]
    pub fn authorization_url(&self) -> String {
        self.0.authorization_url().as_str().to_string()
    }

    /// Block until the user approves on their signer device; returns a `Session`.
    ///
    /// @returns {Promise<Session>}
    /// Resolves when approved; rejects on timeout/cancel/network errors.
    ///
    /// @throws {PubkyJsError}
    /// - `RequestError` if relay/network fails
    /// - `AuthenticationError` if approval is denied/invalid
    #[wasm_bindgen(js_name = "awaitApproval")]
    pub async fn await_approval(self) -> JsResult<Session> {
        Ok(Session(self.0.await_approval().await?))
    }

    /// Block until the user approves on their signer device; returns an `AuthToken`.
    ///
    /// @returns {Promise<AuthToken>}
    /// Resolves when approved; rejects on timeout/cancel/network errors.
    ///
    /// @throws {PubkyJsError}
    /// - `RequestError` if relay/network fails
    #[wasm_bindgen(js_name = "awaitToken")]
    pub async fn await_token(self) -> JsResult<AuthToken> {
        Ok(AuthToken(self.0.await_token().await?))
    }

    /// Non-blocking single poll step (advanced UIs).
    ///
    /// @returns {Promise<Session|null>} A session if the approval arrived, otherwise `null`.
    #[wasm_bindgen(js_name = "tryPollOnce")]
    pub async fn try_poll_once(&self) -> JsResult<Option<Session>> {
        Ok(self.0.try_poll_once().await?.map(Session))
    }
}
```
./src/actors/session.rs
```
// js/src/wrappers/session.rs
use wasm_bindgen::prelude::*;

use super::storage::SessionStorage;
use crate::js_error::{JsResult, PubkyJsError};
use crate::wrappers::session_info::SessionInfo;

/// An authenticated context “as the user”.
/// - Use `storage()` for reads/writes (absolute paths like `/pub/app/file.txt`)
/// - Cookie is managed automatically by the underlying fetch client
#[wasm_bindgen]
pub struct Session(pub(crate) pubky::PubkySession);

#[wasm_bindgen]
impl Session {
    /// Retrieve immutable info about this session (user & capabilities).
    ///
    /// @returns {SessionInfo}
    #[wasm_bindgen]
    pub fn info(&self) -> SessionInfo {
        SessionInfo(self.0.info().clone())
    }

    /// Access the session-scoped storage API (read/write).
    ///
    /// @returns {SessionStorage}
    #[wasm_bindgen]
    pub fn storage(&self) -> SessionStorage {
        SessionStorage(pubky::SessionStorage::new(&self.0))
    }

    /// Invalidate the session on the server (clears server cookie).
    /// It also consumes this JS/Wasm Session. Further calls will fail.
    ///
    /// @returns {Promise<void>}
    #[wasm_bindgen]
    pub async fn signout(self) -> JsResult<()> {
        match self.0.signout().await {
            Ok(()) => Ok(()),
            Err((e, _s)) => Err(PubkyJsError::from(e)),
        }
    }
}

impl From<pubky::PubkySession> for Session {
    fn from(s: pubky::PubkySession) -> Self {
        Session(s)
    }
}
```
./src/actors/mod.rs
```
pub mod auth_flow;
pub mod pkdns;
pub mod session;
pub mod signer;
pub mod storage;
```
./src/actors/pkdns.rs
```
use wasm_bindgen::prelude::*;

use crate::js_error::JsResult;
use crate::wrappers::keys::{Keypair, PublicKey};

/// Resolve/publish `_pubky` PKDNS records (homeserver pointers).
#[wasm_bindgen]
pub struct Pkdns(pub(crate) pubky::Pkdns);

#[wasm_bindgen]
impl Pkdns {
    /// Read-only PKDNS actor (no keypair; resolve only).
    #[wasm_bindgen(constructor)]
    pub fn new() -> JsResult<Pkdns> {
        Ok(Pkdns(pubky::Pkdns::new()?))
    }

    /// PKDNS actor with publishing enabled (requires a keypair).
    #[wasm_bindgen(js_name = "fromKeypair")]
    pub fn from_keypair(keypair: &Keypair) -> JsResult<Pkdns> {
        Ok(Pkdns(pubky::Pkdns::new_with_keypair(
            keypair.as_inner().clone(),
        )?))
    }

    // -------------------- Reads --------------------

    /// Resolve the homeserver for a given public key (read-only).
    ///
    /// @param {PublicKey} user
    /// @returns {Promise<string|undefined>} Homeserver public key (z32) or `undefined` if not found.
    #[wasm_bindgen(js_name = "getHomeserverOf")]
    pub async fn get_homeserver_of(&self, pubky: &PublicKey) -> JsResult<Option<String>> {
        Ok(self.0.get_homeserver_of(pubky.as_inner()).await)
    }

    /// Resolve the homeserver for **this** user (requires keypair).
    ///
    /// @returns {Promise<string|undefined>} Homeserver public key (z32) or `undefined` if not found.
    #[wasm_bindgen(js_name = "getHomeserver")]
    pub async fn get_homeserver(&self) -> JsResult<Option<String>> {
        Ok(self.0.get_homeserver().await?)
    }

    // -------------------- Publishing --------------------

    /// Republish homeserver if record is missing/stale.
    ///
    /// Requires keypair or to be signer bound.
    ///
    /// @param {PublicKey=} overrideHost Optional new homeserver to publish (migration).
    /// @returns {Promise<void>}
    #[wasm_bindgen(js_name = "publishHomeserverForce")]
    pub async fn publish_homeserver_force(&self, host_override: Option<PublicKey>) -> JsResult<()> {
        let host_ref = host_override.as_ref().map(|h| h.as_inner());
        self.0.publish_homeserver_force(host_ref).await?;
        Ok(())
    }

    /// Force publish homeserver immediately (even if fresh).
    ///
    /// Requires keypair or to be signer bound.
    ///
    /// @param {PublicKey=} overrideHost Optional new homeserver to publish (migration).
    /// @returns {Promise<void>}
    #[wasm_bindgen(js_name = "publishHomeserverIfStale")]
    pub async fn publish_homeserver_if_stale(
        &self,
        host_override: Option<PublicKey>,
    ) -> JsResult<()> {
        let host_ref = host_override.as_ref().map(|h| h.as_inner());
        self.0.publish_homeserver_if_stale(host_ref).await?;
        Ok(())
    }
}

impl From<pubky::Pkdns> for Pkdns {
    fn from(inner: pubky::Pkdns) -> Self {
        Pkdns(inner)
    }
}
```
./src/actors/signer.rs
```
use wasm_bindgen::prelude::*;

use super::{pkdns::Pkdns, session::Session};
use crate::js_error::JsResult;
use crate::wrappers::{keys::Keypair, keys::PublicKey};

/// Holds a user’s `Keypair` and performs identity operations:
/// - `signup` creates a new homeserver user.
/// - `signin` creates a homeserver session for an existing user.
/// - Approve pubkyauth requests
/// - Publish PKDNS when signer-bound
#[wasm_bindgen]
pub struct Signer(pub(crate) pubky::PubkySigner);

#[wasm_bindgen]
impl Signer {
    /// Create a signer from a `Keypair` (prefer `pubky.signer(kp)`).
    ///
    /// @param {Keypair} keypair
    /// @returns {Signer}
    #[wasm_bindgen(js_name = "fromKeypair")]
    pub fn new(keypair: &Keypair) -> Signer {
        let signer = pubky::PubkySigner::new(keypair.as_inner().clone())
            .expect("Signer construction should not fail with a valid keypair");
        Signer(signer)
    }

    /// Get the public key of this signer.
    ///
    /// @returns {PublicKey}
    #[wasm_bindgen(js_name = "publicKey")]
    pub fn public_key(&self) -> PublicKey {
        self.0.public_key().into()
    }

    /// Sign up at a homeserver. Returns a ready `Session`.
    ///
    /// Creates a valid homeserver Session with root capabilities
    ///
    /// @param {PublicKey} homeserver The homeserver’s public key.
    /// @param {string|null} signupToken Invite/registration token or `null`.
    /// @returns {Promise<Session>}
    ///
    /// @throws {PubkyJsError}
    /// - `AuthenticationError` (bad/expired token)
    /// - `RequestError` (network/server)
    #[wasm_bindgen]
    pub async fn signup(
        &self,
        homeserver: &PublicKey,
        signup_token: Option<String>,
    ) -> JsResult<Session> {
        let session = self
            .0
            .signup(homeserver.as_inner(), signup_token.as_deref())
            .await?;
        Ok(Session(session))
    }

    /// Fast sign-in for a returning user. Publishes PKDNS in the background.
    ///
    /// Creates a valid homeserver Session with root capabilities
    ///
    /// @returns {Promise<Session>}
    ///
    /// @throws {PubkyJsError}
    #[wasm_bindgen]
    pub async fn signin(&self) -> JsResult<Session> {
        Ok(Session(self.0.signin().await?))
    }

    /// Blocking sign-in. Waits for PKDNS publish to complete (slower; safer).
    ///
    /// Creates a valid homeserver Session with root capabilities
    ///
    /// @returns {Promise<Session>}
    #[wasm_bindgen(js_name = "signinBlocking")]
    pub async fn signin_blocking(&self) -> JsResult<Session> {
        Ok(Session(self.0.signin_blocking().await?))
    }

    /// Approve a `pubkyauth://` request URL (encrypts & POSTs the signed AuthToken).
    #[wasm_bindgen(js_name = "approveAuthRequest")]
    pub async fn approve_auth(&self, pubkyauth_url: String) -> JsResult<()> {
        self.0.approve_auth(&pubkyauth_url).await?;
        Ok(())
    }

    /// Get a PKDNS actor bound to this signer's client & keypair (publishing enabled).
    ///
    /// @returns {Pkdns}
    #[wasm_bindgen]
    pub fn pkdns(&self) -> Pkdns {
        Pkdns(self.0.pkdns())
    }
}
```
./src/pubky.rs
```
use wasm_bindgen::prelude::*;

use crate::actors::{auth_flow::AuthFlow, pkdns::Pkdns, signer::Signer, storage::PublicStorage};
use crate::{client::constructor::Client, js_error::JsResult, wrappers::keys::Keypair};

/// High-level entrypoint to the Pubky SDK.
#[wasm_bindgen]
pub struct Pubky(pub(crate) pubky::Pubky);

#[wasm_bindgen]
impl Pubky {
    /// Create a Pubky façade wired for **mainnet** defaults (public relays).
    ///
    /// @returns {Pubky}
    /// A new façade instance. Use this to create signers, start auth flows, etc.
    ///
    /// @example
    /// const pubky = new Pubky();
    /// const signer = pubky.signer(Keypair.random());
    #[wasm_bindgen(constructor)]
    pub fn new() -> JsResult<Pubky> {
        let client = Client::new(None)?;
        Ok(Pubky(pubky::Pubky::with_client(client.0)))
    }

    /// Create a Pubky façade preconfigured for a **local testnet**.
    ///
    /// If `host` is provided, PKARR and HTTP endpoints are derived as `http://<host>:ports/...`.
    /// If omitted, `"localhost"` is assumed (handy for `cargo install pubky-testnet`).
    ///
    /// @param {string=} host Optional host (e.g. `"localhost"`, `"docker-host"`, `"127.0.0.1"`).
    /// @returns {Pubky}
    ///
    /// @example
    /// const pubky = Pubky.testnet();              // localhost default
    /// const pubky = Pubky.testnet("docker-host"); // custom hostname/IP
    #[wasm_bindgen(js_name = "testnet")]
    pub fn testnet(host: Option<String>) -> JsResult<Pubky> {
        let client = Client::testnet(host)?;
        Ok(Pubky(pubky::Pubky::with_client(client.0)))
    }

    /// Wrap an existing configured HTTP client into a Pubky façade.
    ///
    /// @param {Client} client A previously constructed client.
    /// @returns {Pubky}
    ///
    /// @example
    /// const client = Client.testnet();
    /// const pubky = Pubky.withClient(client);
    #[wasm_bindgen(js_name = "withClient")]
    pub fn with_client(client: &Client) -> Pubky {
        Pubky(pubky::Pubky::with_client(client.0.clone()))
    }

    /// Start a **pubkyauth** flow.
    ///
    /// Provide a **capabilities string** and (optionally) a relay base URL.
    /// The capabilities string is a comma-separated list of entries:
    /// `"<scope>:<actions>"`, where:
    /// - `scope` starts with `/` (e.g. `/pub/example.app/`).
    /// - `actions` is any combo of `r` and/or `w` (order normalized; `wr` -> `rw`).
    /// Pass `""` for no scopes (read-only public session).
    ///
    /// @param {string} capabilities Comma-separated caps, e.g. `"/pub/app/:rw,/pub/foo/file:r"`.
    /// @param {string=} relay Optional HTTP relay base (e.g. `"https://…/link/"`).
    /// @returns {AuthFlow}
    /// A running auth flow. Call `authorizationUrl()` to show a QR/deeplink,
    /// then `awaitApproval()` to obtain a `Session`.
    ///
    /// @throws {PubkyJsError}
    /// - `{ name: "InvalidInput" }` for malformed capabilities or bad relay URL
    /// - `{ name: "RequestError" }` if the flow cannot be started (network/relay)
    ///
    /// @example
    /// const flow = pubky.startAuthFlow("/pub/my.app/:rw");
    /// renderQr(flow.authorizationUrl());
    /// const session = await flow.awaitApproval();
    #[wasm_bindgen(js_name = "startAuthFlow")]
    pub fn start_auth_flow(&self, capabilities: &str, relay: Option<String>) -> JsResult<AuthFlow> {
        let flow = AuthFlow::start_with_client(capabilities, relay, Some(self.0.client().clone()))?;
        Ok(flow)
    }

    /// Create a `Signer` from an existing `Keypair`.
    ///
    /// @param {Keypair} keypair The user’s keys.
    /// @returns {Signer}
    ///
    /// @example
    /// const signer = pubky.signer(Keypair.random());
    /// const session = await signer.signup(homeserverPk, null);
    #[wasm_bindgen(js_name = "signer")]
    pub fn signer(&self, keypair: Keypair) -> Signer {
        Signer(self.0.signer(keypair.as_inner().clone()))
    }

    /// Public, unauthenticated storage API.
    ///
    /// Use for **read-only** public access via addressed paths:
    /// `"<user-z32>/pub/…"`.
    ///
    /// @returns {PublicStorage}
    ///
    /// @example
    /// const pub = pubky.publicStorage();
    /// const text = await pub.getText(`${userPk.z32()}/pub/example.com/hello.txt`);
    #[wasm_bindgen(js_name = "publicStorage")]
    pub fn public_storage(&self) -> PublicStorage {
        PublicStorage(self.0.public_storage())
    }

    /// Read-only PKDNS (Pkarr) resolver.
    ///
    /// @returns {Pkdns}
    ///
    /// @example
    /// const dns = pubky.pkdns();
    /// const homeserver = await dns.getHomeserverOf(userPk);
    #[wasm_bindgen]
    pub fn pkdns(&self) -> Pkdns {
        Pkdns(self.0.pkdns())
    }

    /// Access the underlying HTTP client (advanced).
    ///
    /// @returns {Client}
    /// Use this for low-level `fetch()` calls or testing with raw URLs.
    ///
    /// @example
    /// const r = await pubky.client().fetch(`pubky://${user}/pub/app/file.txt`, { credentials: "include" });
    #[wasm_bindgen]
    pub fn client(&self) -> Client {
        Client(self.0.client().clone())
    }
}
```
./src/utils.rs
```
use wasm_bindgen::prelude::*;

/// Set the global logging verbosity for the WASM Pubky SDK. Routes Rust `log` output to the browser console.
///
/// Accepted values (case-insensitive): "error" | "warn" | "info" | "debug" | "trace".
/// Effects:
/// - Initializes the logger once; subsequent calls may throw if the logger is already set.
/// - Emits a single info log: `Log level set to: <level>`.
/// - Messages at or above `level` are forwarded to the appropriate `console.*` method.
///
/// @param {string} level
///        Minimum log level to enable. One of: "error" | "warn" | "info" | "debug" | "trace".
///
/// @returns {void}
///
/// @throws {Error}
///         If `level` is invalid ("Invalid log level") or the logger cannot be initialized
///         (e.g., already initialized).
///
/// Usage:
///   Call once at application startup, before invoking other SDK APIs.
#[wasm_bindgen(js_name = "setLogLevel")]
pub fn set_log_level(level: &str) -> Result<(), JsValue> {
    let level = match level.to_lowercase().as_str() {
        "error" => log::Level::Error,
        "warn" => log::Level::Warn,
        "info" => log::Level::Info,
        "debug" => log::Level::Debug,
        "trace" => log::Level::Trace,
        _ => return Err(JsValue::from_str("Invalid log level")),
    };

    console_log::init_with_level(level).map_err(|e| JsValue::from_str(&e.to_string()))?;
    log::info!("Log level set to: {}", level);
    Ok(())
}
```
./src/client/mod.rs
```
pub mod constructor;
pub mod http;
```
./src/client/http.rs
```
//! Fetch method handling HTTP and Pubky urls with Pkarr TLD.

use js_sys::{Promise, Reflect};
use url::Url;
use wasm_bindgen::prelude::*;
use web_sys::{Headers, Request, RequestCredentials, RequestInit, ServiceWorkerGlobalScope};

use super::constructor::Client;
use crate::js_error::JsResult;

#[wasm_bindgen]
impl Client {
    /// Perform a raw fetch. Works with `pubky://` or `http(s)://` URLs.
    ///
    /// @param {string} url
    /// @param {RequestInit=} init Standard fetch options; `credentials: "include"` recommended for session I/O.
    /// @returns {Promise<Response>}
    ///
    /// @example
    /// const client = pubky.client();
    /// const res = await client.fetch(`pubky://${user}/pub/app/file.txt`, { method: "PUT", body: "hi", credentials: "include" });
    #[wasm_bindgen]
    pub async fn fetch(&self, url: &str, init: Option<RequestInit>) -> JsResult<Promise> {
        // 1) Parse URL
        let mut url = Url::parse(url)?;

        // 2) Ask the SDK to prepare (rewrite pubky://, resolve pkarr, etc.)
        //    Returns Some(<z32>) iff this is a pubky:// request.
        let pubky_host = self.0.prepare_request(&mut url).await?;

        // 3) Start from caller's init; DO NOT clobber headers.
        let req_init = init.unwrap_or_default();

        // 3a) If needed, ensure `pubky-host` is present in *init.headers* BEFORE Request creation.
        if let Some(host) = pubky_host.as_deref() {
            // Try to read any existing headers off RequestInit via reflection.
            // This value can be: undefined/null (no headers), a real `Headers`, or
            // a plain object/array. We handle those cases explicitly.
            let headers_js = Reflect::get(req_init.as_ref(), &JsValue::from_str("headers"))
                .unwrap_or(JsValue::UNDEFINED);

            if headers_js.is_undefined() || headers_js.is_null() {
                // No headers -> create and set ours.
                let headers = Headers::new()?;
                headers.set("pubky-host", host)?;
                req_init.set_headers(&headers.into());
            } else if headers_js.is_instance_of::<Headers>() {
                // Already a `Headers` object -> mutate in place (don’t replace).
                let headers: Headers = headers_js.unchecked_into();
                headers.set("pubky-host", host)?;
                // No need to set_headers again; we mutated the same object.
            } else {
                // Some non-`Headers` thing (e.g., plain object/array).
                // Safest is to replace with a real `Headers` that includes `pubky-host`.
                // (Our SDK paths pass a `Headers` already.)
                let headers = Headers::new()?;
                headers.set("pubky-host", host)?;
                req_init.set_headers(&headers.into());
            }
        }

        // 4) Always include credentials (cookies)
        req_init.set_credentials(RequestCredentials::Include);

        // 5) Build the Request *after* headers/credentials are set
        let js_req = Request::new_with_str_and_init(url.as_str(), &req_init)
            .map_err(|_| JsValue::from_str("invalid RequestInit"))?;

        // 6) Dispatch using the proper global (SW or Window)
        Ok(js_fetch(&js_req))
    }
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_name = fetch)]
    fn fetch_with_request(input: &web_sys::Request) -> Promise;
}

fn js_fetch(req: &web_sys::Request) -> Promise {
    use wasm_bindgen::{JsCast, JsValue};
    let global = js_sys::global();
    if let Ok(true) = js_sys::Reflect::has(&global, &JsValue::from_str("ServiceWorkerGlobalScope"))
    {
        global
            .unchecked_into::<ServiceWorkerGlobalScope>()
            .fetch_with_request(req)
    } else {
        // Browser
        fetch_with_request(req)
    }
}

#[cfg(all(test, target_arch = "wasm32"))]
mod tests {
    use super::*;
    use pkarr::Keypair;
    use wasm_bindgen_test::*;

    wasm_bindgen_test_configure!(run_in_browser);

    // Ensure we expose pubky-host AND set credentials=include for pubky:// URLs
    #[wasm_bindgen_test(async)]
    async fn prepare_sets_pubky_host_and_credentials() {
        let client = Client::testnet(None);
        let pk = Keypair::random().public_key().to_string();
        let mut url = Url::parse(&format!("pubky://{}/pub/file.txt", pk)).unwrap();

        // Mirror the `fetch()` code path (but don't actually dispatch fetch)
        let mut req_init = RequestInit::new();
        let host_opt = client.0.prepare_request(&mut url).await.unwrap();
        assert_eq!(host_opt.as_deref(), Some(pk.as_str()));

        req_init.set_credentials(RequestCredentials::Include);
        assert_eq!(req_init.credentials(), Some(RequestCredentials::Include));
    }

    // ICANN URL must not require pubky-host but should still allow credentials=include
    #[wasm_bindgen_test(async)]
    async fn prepare_icann_does_not_set_pubky_host() {
        let client = Client::new(None).unwrap();
        let mut url = Url::parse("https://example.com/").unwrap();

        let host_opt = client.0.prepare_request(&mut url).await.unwrap();
        assert!(host_opt.is_none());
    }
}
```
./src/client/constructor.rs
```
// js/src/constructor.rs
use std::time::Duration;

use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::prelude::*;

use crate::js_error::{JsResult, PubkyErrorName, PubkyJsError};

static TESTNET_RELAY_PORT: &str = "15411";

// ------------------------------------------------------------------------------------------------
// JS style config objects for the client.
// ------------------------------------------------------------------------------------------------

/// Pkarr Config
#[derive(Tsify, Serialize, Deserialize, Debug)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct PkarrConfig {
    /// The list of relays to access the DHT with.
    #[tsify(optional)]
    pub(crate) relays: Option<Vec<String>>,
    /// The timeout for DHT requests in milliseconds.
    /// Default is 2000ms.
    #[tsify(optional)]
    pub(crate) request_timeout: Option<u64>,
}

/// Pubky Client Config
#[derive(Tsify, Serialize, Deserialize, Debug)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct PubkyClientConfig {
    /// Configuration on how to access pkarr packets on the mainline DHT.
    #[tsify(optional)]
    pub(crate) pkarr: Option<PkarrConfig>,
    // NOTE: user_max_record_age belonged to the old client — removed here.
}

/// Low-level HTTP bridge used by the Pubky façade and actors.
///
/// - Supports `pubky://<user-z32>/<abs-path>` and `http(s)://` URLs.
/// - In browsers/undici, passes `credentials: "include"` to send cookies.
#[wasm_bindgen]
pub struct Client(pub(crate) pubky::PubkyHttpClient);

impl Default for Client {
    fn default() -> Self {
        Self::new(None).expect("default constructor should be infallible")
    }
}

#[wasm_bindgen]
impl Client {
    /// Create a Pubky HTTP client.
    ///
    /// @param {PubkyClientConfig} [config]
    /// Optional transport overrides:
    /// `{ pkarr?: { relays?: string[], request_timeout?: number } }`.
    ///
    /// @returns {Client}
    /// A configured low-level client. Prefer `new Pubky().client()` unless you
    /// need custom relays/timeouts.
    ///
    /// @throws {InvalidInput}
    /// If any PKARR relay URL is invalid.
    ///
    /// @example
    /// const client = new Client({
    ///   pkarr: { relays: ["https://relay1/","https://relay2/"], request_timeout: 8000 }
    /// });
    /// const pubky = Pubky.withClient(client);
    #[wasm_bindgen(constructor)]
    pub fn new(config_opt: Option<PubkyClientConfig>) -> JsResult<Self> {
        let mut builder = pubky::PubkyHttpClient::builder();

        if let Some(config) = config_opt {
            if let Some(pkarr) = config.pkarr {
                // Relays
                if let Some(relays) = pkarr.relays {
                    let mut relay_set_error: Option<String> = None;
                    builder.pkarr(|p| {
                        p.no_relays();
                        if let Err(e) = p.relays(&relays) {
                            relay_set_error = Some(e.to_string());
                        }
                        p
                    });
                    if let Some(msg) = relay_set_error {
                        return Err(PubkyJsError::new(PubkyErrorName::InvalidInput, msg));
                    }
                }
                // Timeout
                if let Some(timeout_ms) = pkarr.request_timeout {
                    builder.pkarr(|p| {
                        p.request_timeout(Duration::from_millis(timeout_ms));
                        p
                    });
                }
            }
        }

        let client = builder.build()?;
        log::debug!("Client created: {:?}", client);

        Ok(Self(client))
    }

    /// Create a client wired for **local testnet**.
    ///
    /// Sets PKARR relays to `http://<host>:15411/` and enables WASM `pubky://`
    /// mapping for that host.
    ///
    /// @param {string} [host="localhost"]
    /// Testnet hostname or IP.
    ///
    /// @returns {Client}
    /// A client ready to talk to your local testnet.
    ///
    /// @example
    /// const client = Client.testnet();           // localhost
    /// const pubky  = Pubky.withClient(client);
    ///
    /// @example
    /// const client = Client.testnet("docker0");  // custom host
    #[wasm_bindgen]
    pub fn testnet(host: Option<String>) -> JsResult<Self> {
        let hostname = host.unwrap_or_else(|| "localhost".to_string());
        let relay = format!("http://{}:{}/", hostname, TESTNET_RELAY_PORT);

        let mut builder = pubky::PubkyHttpClient::builder();
        builder.pkarr(|p| p.relays(&[relay.as_str()]).expect("valid testnet relay"));
        builder.testnet_host(Some(hostname));

        let client = builder.build()?;
        log::debug!("Client created: {:?}", client);

        Ok(Self(client))
    }
}
```
./src/js_error.rs
```
use std::fmt::Display;

use serde::{Deserialize, Serialize};
use tsify::Tsify;
use wasm_bindgen::prelude::*;

use pkarr::errors::PublicKeyError;
use pubky::errors::{BuildError, RequestError};
use pubky_common::auth::Error as AuthTokenError;
use pubky_common::capabilities::Error as CapabilitiesError;
use pubky_common::recovery_file::Error as RecoveryFileError;

/// A convenient `Result` type alias for fallible functions exposed to WebAssembly.
///
/// An `Err` variant will be automatically converted into a structured JavaScript exception
/// that can be caught on the JS side.
pub type JsResult<T> = Result<T, PubkyJsError>;

// --- TypeScript Documentation & Schema ---

/// A union type of all possible machine-readable codes for the `name` property
/// of a {@link PubkyJsError}.
///
/// Provides a simplified, actionable set of error categories for developers
/// to handle in their code.
#[derive(Tsify, Serialize, Deserialize, Debug)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "PascalCase")]
pub enum PubkyErrorName {
    /// A network or server request failed. Check the network connection or retry.
    RequestError,
    /// The error was caused by invalid user input, such as a malformed URL.
    InvalidInput,
    /// An error occurred during login, signup, or session validation.
    AuthenticationError,
    /// A failure in the underlying Pkarr DHT protocol.
    PkarrError,
    /// An error related to client state, like a corrupt recovery file.
    ClientStateError,
    /// An unexpected or internal error occurred. This may indicate a bug.
    InternalError,
}

/// Represents the standard error structure for all exceptions thrown by the Pubky
/// WASM client.
///
/// @property name - A machine-readable error code from {@link PubkyErrorName}. Use this for programmatic error handling.
/// @property message - A human-readable, descriptive error message suitable for logging.
/// @property data - An optional payload containing structured context for an error. For a `RequestError`, this may contain an object with the HTTP status code, e.g., `{ statusCode: 404 }`.
///
/// @example
/// ```typescript
/// try {
///   await client.signup(...);
/// } catch (e) {
///   const error = e as PubkyJsError;
///   if (error.name === 'RequestError' && error.statusCode === 404) {
///     // Handle not found...
///   }
/// }
/// ```
#[derive(Tsify, Serialize, Deserialize, Debug)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct PubkyJsError {
    pub name: PubkyErrorName,
    pub message: String,

    /// For `RequestError::Server`, this carries the numeric HTTP status code (e.g. 404).
    /// Otherwise `undefined` on the JS side.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[tsify(optional)]
    pub status_code: Option<u16>,
}

// --- Constructors for Ergonomics ---
impl PubkyJsError {
    /// Creates a new error with a name and message.
    pub fn new<T: Display>(name: PubkyErrorName, message: T) -> Self {
        Self {
            name,
            message: message.to_string(),
            status_code: None,
        }
    }

    /// Creates a new error with a name, message, and structured data payload.
    pub fn new_with_status<T: Display>(name: PubkyErrorName, message: T, status: u16) -> Self {
        Self {
            name,
            message: message.to_string(),
            status_code: Some(status),
        }
    }
}

// --- Rust-to-JavaScript pubky::Error Conversion Pipeline ---

/// Converts a native `pubky::Error` into a `PubkyJsError`.
impl From<pubky::Error> for PubkyJsError {
    fn from(err: pubky::Error) -> Self {
        let name = match &err {
            pubky::Error::Request(_) => PubkyErrorName::RequestError,
            pubky::Error::Parse(_) => PubkyErrorName::InvalidInput,
            pubky::Error::Authentication(_) => PubkyErrorName::AuthenticationError,
            pubky::Error::Pkarr(_) => PubkyErrorName::PkarrError,
            pubky::Error::Build(_) => PubkyErrorName::InternalError,
        };

        // If this was a server error, attach status_code; else leave it None.
        if let pubky::Error::Request(RequestError::Server { status, .. }) = &err {
            return Self::new_with_status(name, &err, status.as_u16());
        }
        Self::new(name, err)
    }
}

/// Converts a `pubky::BuildError` into a `PubkyJsError`.
impl From<BuildError> for PubkyJsError {
    fn from(err: BuildError) -> Self {
        Self::new(PubkyErrorName::InternalError, err)
    }
}

/// Converts a `pubky_common::recovery_file::Error` into a `PubkyJsError`.
impl From<RecoveryFileError> for PubkyJsError {
    fn from(err: RecoveryFileError) -> Self {
        Self::new(PubkyErrorName::ClientStateError, err)
    }
}

/// Converts a `pubky_common::capabilities::Error` into a `PubkyJsError`.
impl From<CapabilitiesError> for PubkyJsError {
    fn from(err: CapabilitiesError) -> Self {
        Self::new(PubkyErrorName::InvalidInput, err.to_string())
    }
}

/// Converts an AuthToken parsing/verification error into a `PubkyJsError`.
impl From<AuthTokenError> for PubkyJsError {
    fn from(err: AuthTokenError) -> Self {
        // Treat any token parse/verify failure as an authentication failure.
        // (No HTTP status here; it's a local verification error.)
        PubkyJsError::new(PubkyErrorName::AuthenticationError, err.to_string())
    }
}

/// Converts a `url::ParseError` into a `PubkyJsError`.
impl From<url::ParseError> for PubkyJsError {
    fn from(err: url::ParseError) -> Self {
        Self::new(PubkyErrorName::InvalidInput, err)
    }
}

/// Converts a `pkarr::PublicKeyError` into a `PubkyJsError`.
impl From<PublicKeyError> for PubkyJsError {
    fn from(err: PublicKeyError) -> Self {
        Self::new(PubkyErrorName::InvalidInput, err)
    }
}

/// Converts a `serde_wasm_bindgen::Error` (JS <-> Rust value (de)serialization) into `PubkyJsError`.
impl From<serde_wasm_bindgen::Error> for PubkyJsError {
    fn from(err: serde_wasm_bindgen::Error) -> Self {
        // Treat bad JS values / schema mismatches as invalid input.
        PubkyJsError::new(PubkyErrorName::InvalidInput, err)
    }
}

/// Converts a `reqwest::Error` into a `PubkyJsError`.
impl From<reqwest::Error> for PubkyJsError {
    fn from(err: reqwest::Error) -> Self {
        // Try to propagate status when present
        if let Some(status) = err.status() {
            PubkyJsError::new_with_status(
                PubkyErrorName::RequestError,
                err.to_string(),
                status.as_u16(),
            )
        } else {
            PubkyJsError::new(PubkyErrorName::RequestError, err.to_string())
        }
    }
}

/// Converts a generic `JsValue` error into a `PubkyJsError`.
impl From<JsValue> for PubkyJsError {
    fn from(err: JsValue) -> Self {
        let message = err
            .as_string()
            .unwrap_or_else(|| "An unknown JavaScript error occurred.".to_string());
        Self::new(PubkyErrorName::InternalError, message)
    }
}
```
./src/lib.rs
```
pub mod actors;
pub mod client;
mod js_error;
pub mod pubky;
pub mod utils;
pub mod wrappers;
```
./.cargo/config.toml
```
[target.wasm32-unknown-unknown]
rustflags = ["--cfg", "getrandom_backend=\"wasm_js\""]
```
./README.md
```
# JS Pubky SDK bindings

Wasm-pack wrap of [Pubky](https://github.com/pubky/pubky-core) SDK.

## How To Build/Test the NPM Package

1. Go to `pubky-sdk/bindings/js/pkg`.
2. Run `npm run build`.
3. Run a testnet mainline DHT, Pkarr relay and Homeserver `npm run testnet`
4. Run tests with `npm run test`.
```
./Cargo.toml
```
[package]
name = "pubky-wasm"
version = "0.6.0-rc.4"
edition = "2024"
description = "Pubky-Core Client WASM bindings"
authors = [
    "SeverinAlexB <severin@synonym.to>",
    "SHAcollision <shacollision@synonym.to>",
    "Nuh <nuh@nuh.dev>",
]
license = "MIT"
homepage = "https://github.com/pubky/pubky-core"
repository = "https://github.com/pubky/pubky-core"
keywords = ["web", "dht", "dns", "decentralized", "identity"]
categories = [
    "network-programming",
    "cryptography",
    "web-programming",
    "authentication",
]
publish = false # Do not publish to crates.io, only publish to npmjs.com

[lib]
crate-type = ["cdylib"]

[[bin]]
name = "bundle_npm"
path = "scripts/bundle_npm.rs"

[dependencies]
wasm-bindgen = "0.2.100"
console_log = { version = "1.0.0", features = ["color"] }
log = "0.4.27"
js-sys = "0.3.77"
wasm-bindgen-futures = "0.4.50"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1"
serde-wasm-bindgen = "0.6"
tsify = "0.5.5"
pubky = { path = "../../../pubky-sdk", default-features = false, features = [
    "json",
] }
pkarr = { workspace = true, default-features = false }
pubky-common = { path = "../../../pubky-common" }
web-sys = { version = "0.3.77", default-features = false, features = [
    "Request",
    "RequestInit",
    "RequestCredentials",
    "Headers",
    "ServiceWorkerGlobalScope",
] }
url = "2.5.4"
getrandom = { version = "0.3.3", features = ["wasm_js"] }
reqwest = { version = "0.12.12", default-features = false }
```
